import java.io.File;
import java.lang.Character.Subset;
import java.lang.ProcessHandle.Info;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
import java.util.Locale.Category;

import javax.xml.catalog.CatalogResolver;

import java.util.Scanner ; 

public class Step3WorkingOffextended {
	//global 2d arrays
	public static double[][] allStudents;
	public static String[][] infoInStrings;
   
    

	//all students but with the ng values to simulate more efficiently
	public static double[][] allStudentsNG;
	public static Random generator = new Random();
    public static void main(String[] args) {
        try {
            System.out.println("give me the course as a number, the number 0 is the first course ect");
            Scanner sc = new Scanner(System.in);
            int Num = sc.nextInt() ; 

            studentInfo(); 
            monteCarlo(false);

        	// how i think it should work is that i check if he has C then if he does i predic it if not i go  to the second best and ext!!

			//SIMULATES THE BEST CATEGORIES in StudentInfo.csv using montecarlo simulation
			for( int i = Num ; i<34 ;i++){
				String answer = finalAnswer(i, 100);// possible idea to get better ranges is to find a way to get the smallest yet best ranges to sort the data out
				System.out.println(answer);

			}



        } catch (Exception ex) {
            ex.printStackTrace();
		}
    }

    public static double average(int course ) {
        double sum = 0; 
        
        for( int i = 0 ; i <allStudents.length ; i++ ){
            sum += allStudents[i][course];

        }
        double average = sum/allStudents.length ; 
 
        return average; 

    }
    public static double average2(double [] categoryArray , int course ) {
        double sum = 0; 
        
        for( int i = 0 ; i <categoryArray.length ; i++ ){
            sum += categoryArray[i];

        }
        double average = sum/categoryArray.length ; 
 
        return average; 

    }
    public static double TotalVariance2 ( double[] categoryArray , int course){
        double TotalVar= 0 ; 
        double sum = 0 ; 
        double average1Z = average2(categoryArray, course);

        for( int i = 0 ; i <categoryArray.length ; i++ ){
            sum += Math.pow(Math.abs(categoryArray[i] - average1Z), 2);
        }
        TotalVar = sum/allStudents.length ; 

        return TotalVar; 
    }
    public static double TotalVariance (int course){
        double TotalVar= 0 ; 
        double sum = 0 ; 
        double average1Z = average(course);

        for( int i = 0 ; i <allStudents.length ; i++ ){
            sum += Math.pow(Math.abs(allStudents[i][course] - average1Z), 2);
        }
        TotalVar = sum/allStudents.length ; 

        return TotalVar; 
    }

	
    public static double calculateWeightedVariance(String Categroy, int course, int Catnum ) {// change the parameter to the subCatergory A or whatever to make it specific for what you want.
            int Counter = 0;

            // Count the occurrences of each grade for the specific sub parameter
            for (int i = 0; i < infoInStrings.length; i++) {
                if(infoInStrings[i][Catnum].equals(Categroy)){
                    Counter++;
                }
            }
        
            // Calculate the weighted mean using the counts as weights!!
            double weight = (double) Counter/allStudents.length;

        double variance = 0;
        // Total variance but specific to category[i] 
		ArrayList<Double> CategoryListSpec = new ArrayList<Double>();
        for (int j = 0; j < allStudents.length; j++) {
            if(infoInStrings[j][Catnum].equals(Categroy)) {
                CategoryListSpec.add(allStudents[j][course]);
            }
        }

		double[] categoryArray = new double[CategoryListSpec.size()];
        for (int i = 0; i < CategoryListSpec.size(); i++) {
            categoryArray[i] = CategoryListSpec.get(i);
        }
        variance = TotalVariance2(categoryArray, course);

        return weight*variance;
    }
    public static double VarianceReduction(String Categroy, int course, int Catnum ) {
        double TVar =  TotalVariance(course);
        double WeightR = calculateWeightedVariance(Categroy, course, Catnum);
        double VarianceRed = 0 ; 
        
        VarianceRed = Math.floor(1000*(Math.abs(TVar - WeightR)))/1000;

        return VarianceRed ; 
    }
    public static double[] varianceReductions(String[] Category, int course, int Catnum) {
        double[] varianceReductions = new double[Category.length];
        for (int i = 0; i < Category.length; i++) {
            varianceReductions[i] = VarianceReduction(Category[i], course, Catnum);
        }

        return varianceReductions;
    }
    public static String[] bestCategory(String[] Category, int course, int catNum) throws Exception{

            double min = 0;     
            int index = 0;      
            String [] answer = new String[3];

            double[] varianceReductions = varianceReductions(Category, course, catNum);
            
            for (int i = 0; i < varianceReductions.length; i++) {
                if(varianceReductions[i] >= min) {
                    min = varianceReductions[i];
                    index = i;
                }
            }
            answer[0] = String.valueOf(min);
            answer[1] = Category[index];
            answer[2] = String.valueOf(index);
            return answer;
        }
    public static double[][] simulateBestCategory(String[] Category, int course, int catNum, int simulations) throws Exception {
            int[] CategoryBestAmount = new int[Category.length];
            double [][] name = new double[Category.length+1][simulations];

			System.out.println("Simulating: " + Arrays.toString(Category) + " with " + simulations + " simulations for course " + course);

			for (int i = 0; i < simulations; i++) {
                monteCarlo(true);
				String[] currentBest = bestCategory(Category, course, catNum);
				name[Integer.parseInt(currentBest[2])+1][i] = Double.parseDouble(currentBest[0]);
                CategoryBestAmount[Integer.parseInt(currentBest[2])]++;
            }
            
            int max = 0;
            int bestIndex = 0;

            for (int i = 0; i < CategoryBestAmount.length; i++) {
                if (CategoryBestAmount[i] >= max) {
                    max = CategoryBestAmount[i];
                    bestIndex = i;
                }
            }
			for( int i =0 ; i<simulations ; i++){


			}

            System.out.println("The best category is " + Category[bestIndex] + " with " + max + "/" + simulations + " matches");
            name[0][0] = bestIndex;
            
            return name;
        
        }
	
    
    


    public static double calculateWeightedVariance2(int Categroy1,int Category2, int course, int Catnum ) {// change the parameter to the subCatergory A or whatever to make it specific for what you want.
            int Counter = 0;

            // Count the occurrences of each grade for the specific sub parameter
            for (int i = 1; i < infoInStrings.length; i++) {
                if(Integer.parseInt(infoInStrings[i][Catnum])>=(Categroy1) && Integer.parseInt(infoInStrings[i][Catnum])<=(Category2)){
                    Counter++;
                }
            }
        
            // Calculate the weighted mean using the counts as weights!!
            double weight = (double) Counter/allStudents.length;

        double variance = 0;
        // Total variance but specific to category[i] 
		ArrayList<Double> CategoryListSpec = new ArrayList<Double>();
        for (int j = 1; j < allStudents.length; j++) {
            if(Integer.parseInt(infoInStrings[j][Catnum])>=(Categroy1) && Integer.parseInt(infoInStrings[j][Catnum])<=(Category2) ) {
                CategoryListSpec.add(allStudents[j][course]);
            }
        }

		double[] categoryArray = new double[CategoryListSpec.size()];
        for (int i = 0; i < CategoryListSpec.size(); i++) {
            categoryArray[i] = CategoryListSpec.get(i);
        }
        variance = TotalVariance2(categoryArray, course);

        return weight*variance;
    }
    public static double VarianceReduction2(int Category1,int Category2, int course, int Catnum ) {
        double TVar =  TotalVariance(course);
        double WeightR = calculateWeightedVariance2(Category1,Category2, course, Catnum);
        double VarianceRed = 0 ; 
        
        VarianceRed = Math.floor(1000*(Math.abs(TVar - WeightR)))/1000;

        return VarianceRed ; 
    }
    public static double[] varianceReductions2(int[] Category, int course, int Catnum) {
        double[] varianceReductions = new double[Category.length/2];
        int c = 0;
        for (int i = 0; i < Category.length; i+=2) {
            
            varianceReductions[c] = VarianceReduction2(Category[i],Category[i+1], course, Catnum);
            c++;
        }

        return varianceReductions;
    }
    public static double[] bestCategory2(int[] Category, int course, int catNum) throws Exception{

            double min = 0;     
            int index = 0;      
            double [] answer = new double[3];

            double[] varianceReductions = varianceReductions2(Category, course, catNum);
            for (int i = 0, count = 0 ; i < Category.length ; i+=2 , count++) {
                if(varianceReductions[count] >= min) {
                    min = varianceReductions[count];
                    index = i;
                }
            }

            answer[0] = min;
            answer[1] = Category[index];
            answer[2] = index;
            return answer;
        }
    public static double[][] simulateBestCategory2(int[] Category, int course, int catNum, int simulations) throws Exception {
            int[] counters = new int[Category.length];
            int [] name = new int[2];
			double [][] OffName = new double[Category.length/2+2][simulations];

			System.out.println("Simulating: " + Arrays.toString(Category) + " with " + simulations + " simulations for course " + course);
            for (int i = 0; i < simulations; i++) {
                monteCarlo(true);
				double[] currentBest = bestCategory2(Category, course, catNum);
                counters[(int)currentBest[2]]++ ;
				OffName[(int)(currentBest[2])+2][i] = (currentBest[0]);

				
            }
            
            int max = 0;
            int bestIndex = 0;
            

            for (int i = 0; i < counters.length; i++) {
                if (counters[i] >= max) {
                    max = counters[i];
                    bestIndex = i;
                }
            }

            System.out.println("The best category is " + Category[bestIndex]+ " to "+ Category[bestIndex+1]  +" with " + max + "/" + simulations + " matches");
            OffName[0][0] = Category[bestIndex];
            OffName[1][0] = Category[bestIndex + 1] ; 

            
            return OffName;
        
        }
	
    
    
    
    public static String finalAnswer(int Num, int simulations) throws Exception{
			String[] Category1 = {"full", "medium", "low", "nothing", "high"};
			int[] 	 Category2 = {-150, -100, -49 , 0, -99, -50, 1, 50, 51 , 100, 101, 150 };// if the ranges are too small there is an issue of overfitting 
			String[] Category3 = {"1 tau", "2 tau", "3 tau"};
			String[] Category4 = {"A", "B", "C", "D", "E", "F"};
			String[] Category5 = {"0.1 Hz ", "0.5 Hz ", "1.0 Hz ", "5.0 Hz "};

            
			double[][] Category1Best = simulateBestCategory(Category1, Num, 1, simulations);
            double[][] Category2Best = simulateBestCategory2(Category2,Num, 2, simulations);
			double[][] Category3Best = simulateBestCategory(Category3, Num, 3, simulations);
			double[][] Category4Best = simulateBestCategory(Category4, Num, 4, simulations);
			double[][] Category5Best = simulateBestCategory(Category5, Num, 5, simulations);


			int counter[] = new int [5];
			double index1 = Category1Best[0][0];
			double index2 = (Category2Best[0][0]);
			double index3 = Category3Best[0][0];
			double index4 = (Category4Best[0][0]);
			double index5 = (Category5Best[0][0]);
			List<Double> Category1List= new ArrayList<>();
			//List<Double> Category2List= new ArrayList<>();
			List<Double> Category3List= new ArrayList<>();
			List<Double> Category4List= new ArrayList<>();
			List<Double> Category5List= new ArrayList<>();
			int [] LengthsArr = new int[5];



			for ( int i = 0 ; i< simulations ; i++){
				if(Category1Best[(int)index1+1][i] >0.0){
					Category1List.add(Category1Best[(int)index1+1][i]);
					LengthsArr[0] = Category1List.size();
				}

			}
			for ( int i = 0 ; i< simulations ; i++){
				if(Category3Best[(int)index3+1][i] >0.0){
					Category3List.add(Category3Best[(int)index3+1][i]);
					LengthsArr[2] = Category3List.size();
				}
			}
			for ( int i = 0 ; i< simulations ; i++){
				if(Category4Best[(int)index4+1][i] >0.0){
					Category4List.add(Category4Best[(int)index4+1][i]);
					LengthsArr[3] = Category3List.size();

				}
			}
			for ( int i = 0 ; i< simulations ; i++){
				if(Category5Best[(int)index5+1][i] >0.0){
					Category5List.add(Category5Best[(int)index5+1][i]);
					LengthsArr[4] = Category5List.size();

				}

			}
			System.out.println(Category1List);
			System.out.println(Category3List);
			System.out.println(Category4List);
			System.out.println(Category5List);




			// calculates the smallest length
			int length = 5000;
			LengthsArr[1] = 50000; // Initialize with some value for category 2
			int min = LengthsArr[1]; // Start with LengthsArr[1] as the minimum
			
			for (int i = 0; i < LengthsArr.length; i++) {
				if (LengthsArr[i] < min) {
					min = LengthsArr[i]; // Update min if current element is smaller
				}
			}
			
			length = min ; 
			System.out.println(Arrays.toString(LengthsArr));
			System.out.println(length);

			double sum1 = 0 ;
			double sum2 = 0 ; 
			double sum3 = 0 ; 
			double sum4 = 0 ; 
			double sum5 = 0 ;
			
			double average1 = 0 ; 
			double average2 = 0 ; 
			double average3 = 0 ; 
			double average4 = 0 ; 
			double average5 = 0 ; 



			for(int i = 0 ; i<length ; i++){ 
				
			 	sum1+= Category1List.get(i);
			
			
				 
				 sum3+= Category3List.get(i);

				 
			 	sum4+= Category4List.get(i);

				 
				 sum5+= Category5List.get(i);
			

	

			}

			counter[4] = Category5List.size() ;
			counter[2] = Category3List.size() ;
			counter[0] = Category1List.size() ;
			counter[3] = Category4List.size() ;

			System.err.println(Arrays.toString(counter));

			average1 = sum1/counter[0];
			//average2 = sum2/counter[1];
			average3 = sum3/counter[2];
			average4 = sum4/counter[3];
			average5 = sum5/counter[4];

			System.out.println(average1);
			System.out.println(average2);
			System.out.println(average3);
			System.out.println(average4);
			System.out.println(average5);



					if(average1>average2 && average1>average3 && average1>average4 && average1>average5){
						return "The answer is "+Category1[(int)index1];
					 }
					if(average2>average1 && average2>average3 && average2>average4 && average2>average5){
						return "The answer is "+Category3[(int)index3];
					}
				
					if(average3>average1 && average3>average2 && average3>average4 && average3>average5){
						return "The answer is "+Category3[(int)index3];
					}
					if(average4>average1 && average4>average2 && average4>average3 && average4>average5){
						return "The answer is "+Category3[(int)index3];
					}

					if(average5>average1 && average5>average2 && average5>average3 && average5>average4){
						return "The answer is "+Category3[(int)index3];
					}
				
				return "they are the same";
			
			
		// 	if(counter[0]>counter[2]&&counter[0]>counter[3]&&counter[0]>counter[4]){
		// 		return "The answer is "+Category1[(int)index1];
		// 	 }
		// 	if(counter[2]>counter[0]&&counter[2]>counter[3]&&counter[2]>counter[4]){
		// 		return "The answer is "+Category3[(int)index3];
		// 	}
		
		// 	if(counter[3]>counter[0]&&counter[3]>counter[2]&&counter[3]>counter[4]){
		// 		return "The answer is "+Category4[(int)index4];
		// 	}
		// 	if(counter[4]>counter[0]&&counter[4]>counter[2]&&counter[4]>counter[3]){
		// 		return "The answer is "+Category5[(int)index5];
		// 	}
		


		
			
			
			
			
	}
    
    
    
    
    
    
    
    
    
        // Stores all info from StudentInfo.csv into a 2d array
	public static String[][] studentInfo() throws Exception{
		// Adapt this when you want to read and display a different file.
		String fileName = "C:\\\\Users\\\\marco\\\\Documents\\\\Project 1-1\\\\CODE\\\\StudentInfo.csv";
		File file=new File(fileName);
		
		// This code uses two Scanners, one which scans the file line per line
		Scanner fileScanner = new Scanner(file);
		infoInStrings = new String[1329][6];
		
	   

		int rowsDone = 0; 
		int colsDone = 0 ; 
	
		while (fileScanner.hasNextLine() && rowsDone <= 1329) {

			String line = fileScanner.nextLine();
			
			// and one that scans the line entry per entry using the commas as delimiters
			Scanner lineScanner = new Scanner(line);
			lineScanner.useDelimiter(",");
			// increments the rows of the data
			colsDone = 0;
			while (lineScanner.hasNext()) {
				if (lineScanner.hasNextInt()) {
					infoInStrings[rowsDone][colsDone++] = Integer.toString(lineScanner.nextInt());
					
				}  if (lineScanner.hasNextDouble()) {
					infoInStrings[rowsDone][colsDone++] = Double.toString(lineScanner.nextDouble());

				} else {
					infoInStrings[rowsDone][colsDone++] = lineScanner.next();
				}
			}
			rowsDone++;
			lineScanner.close();
		}
        return infoInStrings ; 
	}
	public static void printAllStudents() {
		System.out.println(Arrays.deepToString(allStudents));
	}
	// Stores all info from CurrentGrades.csv into a 2d array and runs a MonteCarlo simulation
	public static double[][] monteCarlo(boolean simulating) throws Exception {
		// Adapt this when you want to read and display a different file.
		if(!simulating) {
			String fileName = "C:\\\\Users\\\\marco\\\\Documents\\\\Project 1-1\\\\CODE\\\\CurrentGrades.csv";
			File file=new File(fileName);
			
			// This code uses two Scanners, one which scans the file line per line
			Scanner fileScanner = new Scanner(file);
			allStudents = new double[1328][33];
			
		

			int linesDone = -1 ; 
			int coursesDone = 0 ;

		
			while (fileScanner.hasNextLine() && linesDone <= 1328) {

				String line = fileScanner.nextLine();
				
				// and one that scans the line entry per entry using the commas as delimiters
				Scanner lineScanner = new Scanner(line);
				lineScanner.useDelimiter(",");
				// increments the rows of the data
				coursesDone = 0;
				while (lineScanner.hasNext()) {
					if (lineScanner.hasNextInt()) {
						int i = lineScanner.nextInt();
					}  if (lineScanner.hasNextDouble()) {
						allStudents[linesDone][coursesDone++] = lineScanner.nextDouble();
					} else {
						String s = lineScanner.next();
						if(s.equals("NG")){

							allStudents[linesDone][coursesDone++] = -1;

						}
					}
				}
				linesDone++;
				lineScanner.close();
			}
			fileScanner.close();
			//stores the array with the ng (-1) values seperately
			allStudentsNG = new double[allStudents.length][];
			for(int i = 0; i < allStudents.length; i++){
				double[] aMatrix = allStudents[i];
				int aLength = aMatrix.length;
				allStudentsNG[i] = new double[aLength];
				System.arraycopy(aMatrix, 0, allStudentsNG[i], 0, aLength);	
			}
		} else {
			//refreshes the ng (-1) values
			allStudents = new double[allStudentsNG.length][];
			for(int i = 0; i < allStudentsNG.length; i++){
				double[] aMatrix = allStudentsNG[i];
				int aLength = aMatrix.length;
				allStudents[i] = new double[aLength];
				System.arraycopy(aMatrix, 0, allStudents[i], 0, aLength);	
			}
		}

		double[][] allCousesCount = new double[33][11];
		for (int i = 0 ; i<33 ; i++){
			double[] array = reps(i);
			for( int j = 0 ; j< 11 ; j++){
				allCousesCount[i][j] = array[j];
			}
		}


		// makin the margins for the randomisation
		double[] ranges = add(allCousesCount, 0);
		int sum = 0 ;// this is going to be the total number or grades; 
		//System.out.println(Arrays.toString(ranges));

		for( int i =0 ; i <ranges.length ; i++){
			sum+= ranges[i];
			
		}

		for( int i = 0 ;  i < allStudents.length ; i++){
			for( int j = 0 ; j< allStudents[0].length ; j++){
				int random = (int)(Math.random()*sum);
				if( allStudents[i][j]== -1.0){
					if(random < ranges[2] && random>=0){
						allStudents[i][j]=2.0 ; 
					}
					if(random <= ranges[3]+ranges[2] && random>=ranges[2]){
						allStudents[i][j]=3.0 ; 

					}
					if(random <= ranges[4]+ranges[3] + ranges[2] && random>=ranges[3]+ ranges[2]){
						allStudents[i][j]=4.0 ; 
					}
					if(random <= ranges[5]+ranges[4]+ranges[3] + ranges[2] && random>=ranges[4]+ranges[3]+ ranges[2]){
						allStudents[i][j]=5.0 ; 
					}
					if(random <= ranges[6]+ ranges[5]+ranges[4]+ranges[3] + ranges[2] && random>=ranges[5]+ranges[4]+ranges[3]+ ranges[2]){
						allStudents[i][j]=6.0 ; 
					}
					if(random <= ranges[7]+ranges[6]+ ranges[5]+ranges[4]+ranges[3] + ranges[2] && random>= ranges[6]+ranges[5]+ranges[4]+ranges[3]+ ranges[2]){
						allStudents[i][j]=7.0 ; 
					}
					if(random <= ranges [8] + ranges[7]+ranges[6]+ ranges[5]+ranges[4]+ranges[3] + ranges[2] && random> ranges[7]+ranges[6]+ranges[5]+ranges[4]+ranges[3]+ ranges[2]){
						allStudents[i][j]=8.0 ; 
					}
					if(random <= ranges [9] +ranges[8]+ ranges[7]+ranges[6]+ ranges[5]+ranges[4]+ranges[3] + ranges[2] && random>=ranges[8]+ranges[7]+ranges[6]+ranges[5]+ranges[4]+ranges[3]+ ranges[2]){
						allStudents[i][j]=9.0 ; 
					}
					if(random <= ranges[10]+ranges [9] +ranges[8]+ ranges[7]+ranges[6]+ ranges[5]+ranges[4]+ranges[3] + ranges[2] && random> ranges[9]+ ranges[8]+ranges[7]+ranges[6]+ranges[5]+ranges[4]+ranges[3]+ ranges[2]){
						allStudents[i][j]=10.0 ; 
					}


				}

			}
			

		}
        return allStudents;
	}
	public static double[] add(double[][] allCousesCount , int invalid){
		double [] count = new double[11] ; 
		double c = 0 ; 
		for( int i = 0 ; i<11 ; i++){
			for( int j = 0; j<33; j++){
			c += allCousesCount[j][i] ;
			}
			count[i]= c ; 
			c=0; 
		}
		return count; 
	}
	public static double[] reps(int classc){
		
		double[] course = new double [11];


		int num0 = 0 ; 
		int num1 = 0 ;
		int num2 = 0 ; 
		int num3 = 0 ; 
		int num4 = 0 ; 
		int num5 = 0 ; 
		int num6 = 0 ; 
		int num7 = 0 ; 
		int num8 = 0 ; 
		int num9 = 0 ; 
		int num10 = 0 ; 
		
			
		for( int j = 0 ; j< allStudents.length ; j++){
			if( allStudents[j][classc] == 0){
				course[0] = num0++ ;
			}
			if( allStudents[j][classc] == 1 ){
				course[1] = num1++ ;
			}
			if( allStudents[j][classc] == 2){
				course[2] = num2++ ;
			}
			if( allStudents[j][classc] == 3 ){
				course[3] = num3++ ;
			}
			if( allStudents[j][classc] == 4 ){
				course[4] = num4++ ;
			}
			if( allStudents[j][classc] == 5 ){
				course[5] = num5++ ;
			}
			if( allStudents[j][classc] == 6 ){
				course[6] = num6++ ;;
			}
			if( allStudents[j][classc] == 7 ){
				course[7] = num7++ ;
			}
			if( allStudents[j][classc] == 8 ){
				course[8] = num8++ ;
			}
			if( allStudents[j][classc] == 9 ){
				course[9] = num9++ ;
			}
			if( allStudents[j][classc] == 10 ){
				course[10] = num10++ ;
			}
			else{

			}

		}
		return course ;
	}
}
